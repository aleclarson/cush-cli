// Generated by CoffeeScript 2.3.0
var args, bun, cush, dest, dev, err, fatal, fs, log, main, parent, path, promise, refresh, slurm, sourceRoot, target, watching, wch;

slurm = require('slurm');

args = slurm({
  o: true, // output path
  t: true, // target platform
  p: true, // production mode
  h: true // help
});

if (/^(-h)?$/.test(args._)) {
  return (async function() {
    var fs, path;
    fs = require('saxon');
    path = require('path');
    console.log((await fs.read(path.resolve(__dirname, '../help.md'))));
    return process.exit();
  })();
}

log = require('lodge');

fatal = function(err) {
  var stack;
  if (typeof err === 'string') {
    log.error(err);
    process.exit(1);
  }
  if (process.env.DEBUG) {
    stack = err.stack.replace(err.name + ': ' + err.message + '\n', '');
    stack = '\n' + log.gray(stack);
  }
  log.error(err.message + (stack || ''));
  return process.exit(1);
};

if (!(main = args[0])) {
  fatal('must provide an entry path');
}

if (!(dest = args.o)) {
  fatal('must provide an output path (-o)');
}

if (!(target = args.t)) {
  // get the ".web" from "bundle.web.js"
  target = /\.([^.\/]+)\.[^.\/]+$/.exec(dest);
  if (target) {
    target = target[1];
  } else {
    fatal('must provide a target (-t)');
  }
}

wch = require('wch');

watching = null;

wch.on('offline', function() {
  if (watching !== false) {
    log.warn('watch mode is ' + log.lred('disabled'), log.coal('(run `wch start` to enable it)'));
    watching = false;
  }
});

wch.on('connect', function() {
  if (watching !== true) {
    log('watch mode is ' + log.lgreen('enabled'));
    watching = true;
  }
});

wch.connect();

fs = require('saxon');

path = require('path');

cush = require('cush');

cush.on('warning', function(evt) {
  return log.warn(evt);
});

cush.on('error', function(evt) {
  return fatal(evt.error);
});

dev = !args.p;

try {
  bun = cush.bundle(main, {target, dev});
} catch (error) {
  err = error;
  fatal(err);
}

if (path.isAbsolute(dest)) {
  dest = path.relative(process.cwd(), dest);
}

parent = path.dirname(dest);

try {
  require('fs').mkdirSync(parent);
} catch (error) {}

// The root of any mapped sources (relative to the sourcemap).
sourceRoot = path.relative(parent, '');

if (dev) {
  bun.save = async function({content, map}) {
    await fs.write(dest, content + this.getSourceMapURL(map));
    return dest;
  };
} else {
  (function() {
    var ext, sha256;
    ({sha256} = require('cush/utils'));
    ext = path.extname(dest);
    return bun.save = async function({content, map}) {
      var name;
      name = dest.slice(0, 1 - ext.length) + sha256(content, 8) + ext;
      await fs.write(name, content + this.getSourceMapURL(path.basename(name)));
      await fs.write(name + '.map', map.toString());
      return name;
    };
  })();
}

promise = null;

refresh = async function() {
  var name, result;
  try {
    result = (await bun.read());
  } catch (error) {
    err = error;
    if (err.line != null) {
      log('');
      log.error(err.message);
      log('  ' + log.coal(path.relative(process.cwd(), err.file) + ':' + err.line + ':' + err.column));
      log('');
      return;
    }
    fatal(err);
  } finally {
    promise = null;
  }
  if (bun.missed.length) {
    log('');
    log(log.red('failed to resolve dependencies: üî•'));
    bun.missed.forEach(function([mod, i]) {
      return log('  ' + mod.deps[i].ref + log.coal(' from ') + bun.relative(mod));
    });
    log('');
    return;
  }
  if (result) {
    log('');
    log('bundled in ' + log.lyellow(bun.elapsed + 'ms ‚ö°Ô∏è'));
    result.map.sourceRoot = sourceRoot;
    name = (await bun.save(result));
    log(`saved as ${log.lblue(name)} üíé`);
    log('');
  }
};

// The initial build.
promise = refresh().catch(fatal);

// Watch for changes in development mode.
dev && cush.on('change', function(file) {
  if (!bun.valid) {
    log.clear();
    promise || (promise = refresh().catch(fatal));
  }
});

// Exit after building in production mode.
dev || promise.then(function() {
  return process.exit(0);
});
