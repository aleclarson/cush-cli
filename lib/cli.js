// Generated by CoffeeScript 2.3.0
var CUSH_PATH, args, bundle, bundles, cush, dest, dev, elaps, err, fatal, format, fs, log, main, parent, parseStack, path, project, readBundle, reading, ref, slurm, sourceRoot, target, watching, wch;

slurm = require('slurm');

args = slurm({
  o: true, // output path
  t: true, // target platform
  f: true, // bundle format
  p: true, // production mode
  h: true // help
});

if (/^(-h)?$/.test(args._)) {
  return (function() {
    var fs, path;
    fs = require('saxon/sync');
    path = require('path');
    console.log(fs.read(path.resolve(__dirname, '../help.md')));
    return process.exit();
  })();
}

log = require('lodge');

fatal = function(err) {
  var stack;
  if (typeof err === 'string') {
    log.error(err);
    process.exit(1);
  }
  if (process.env.DEBUG) {
    stack = parseStack(err);
  }
  log.error(err.message + (stack ? '\n' + log.gray(stack) : ''));
  return process.exit(1);
};

parseStack = function(err) {
  if (err.stack) {
    return err.stack.slice(1 + err.stack.indexOf('\n    at '));
  }
};

if (!(main = args[0])) {
  fatal('must provide an entry path');
}

if (!(target = args.t)) {
  fatal('must provide a target (-t)');
}

path = require('path');

CUSH_PATH = path.join(process.cwd(), 'node_modules', 'cush');

try {
  require.resolve(CUSH_PATH);
} catch (error) {
  err = error;
  CUSH_PATH = require.resolve('cush');
}

cush = require(CUSH_PATH);

project = cush.project(process.cwd());

bundles = project.config.bundles;

if (bundles && bundles[main]) {
  ({dest, format} = bundles[main]);
}

if (!(dest || (dest = args.o))) {
  fatal('must provide an output path (-o)');
}

format || (format = args.f || ((ref = path.extname(dest)) != null ? ref.slice(1) : void 0));

if (typeof format === 'string') {
  format = cush.formats[format] || require(format);
}

if ((format != null ? format.constructor : void 0) !== Function) {
  fatal('must provide a format (-f)');
}

// development mode
dev = !args.p;


// file watcher

wch = require('wch');

watching = null;

wch.on('offline', function() {
  if (watching !== false) {
    log.warn('watch mode is ' + log.lred('disabled'), log.coal('(run `wch start` to enable it)'));
    watching = false;
  }
});

wch.on('connect', function() {
  if (watching !== true) {
    log('watch mode is ' + log.lgreen('enabled'));
    watching = true;
  }
});

wch.connect();


// bundler errors/warnings

cush.on('error', function(evt) {
  return fatal(evt.error);
});

cush.on('warning', function(evt) {
  return log.warn(evt);
});

try {
  
  // create the bundle

  bundle = cush.bundle(main, {format, target, dev});
} catch (error) {
  err = error;
  switch (err.code) {
    case 'NO_FORMAT':
      fatal('must provide a bundle format (-f)');
      break;
    default:
      fatal(err);
  }
}


// create dest directory (if needed)

fs = require('saxon/sync');

if (path.isAbsolute(dest)) {
  dest = path.relative(process.cwd(), dest);
}

parent = path.dirname(dest);

try {
  fs.mkdir(parent);
} catch (error) {}

// The root of any mapped sources (relative to the sourcemap).
sourceRoot = path.relative(parent, '');


// the bundle saver

if (dev) {
  bundle.save = function({content, map}) {
    fs.write(dest, content + this.getSourceMapURL(map));
    return dest;
  };
} else {
  (function() {
    var ext, sha256;
    ({sha256} = require(CUSH_PATH + '/utils'));
    ext = path.extname(dest);
    return bundle.save = function({content, map}) {
      var name;
      name = dest.slice(0, 1 - ext.length) + sha256(content, 8) + ext;
      fs.write(name, content + this.getSourceMapURL(path.basename(name)));
      fs.write(name + '.map', map.toString());
      return name;
    };
  })();
}


// the bundle reader

elaps = require('elaps');

reading = null;

readBundle = async function() {
  var elapsed, name, ref1, ref2, result, source, stack, state, timer;
  timer = elaps();
  try {
    result = (await bundle.read());
  } catch (error) {
    err = error;
    if (err.line != null) {
      source = path.relative('', err.filename || err.file);
      source += ':' + err.line + ':' + ((ref1 = (ref2 = err.col) != null ? ref2 : err.column) != null ? ref1 : 0);
      log('');
      log.error(err.message + log.gray('\n    at ./' + source));
      if (err.snippet) {
        log('\n' + err.snippet);
      }
      if (stack = parseStack(err)) {
        log(log.gray(stack));
      }
      log('');
      return;
    }
    throw err;
  }
  ({state} = bundle);
  if (state.missing) {
    log('');
    log(log.red('Failed to resolve dependencies:'));
    state.missing.forEach(function([asset, dep]) {
      return log('  ' + dep.ref + log.coal(' from ') + bundle.relative(asset.path()));
    });
    log('');
    return;
  }
  if (result) {
    ({elapsed} = timer.stop());
    elapsed = elapsed.toFixed(elapsed > 100 ? 0 : 1);
    log('');
    log('Bundled in %s ms ‚ö°Ô∏è', log.lgreen(elapsed));
    result.map.sourceRoot = sourceRoot;
    name = (await bundle.save(result));
    log(`Saved as ${log.lblue(name)} üíé`);
    log('');
  }
};

// The initial build.
log(log.blue('bundling...'));

readBundle().catch(fatal);

if (dev) {
  bundle.on('rebuild', function() {
    log.clear();
    return log(log.blue('bundling...'));
  });
  bundle.on('invalidate', function() {
    return readBundle().catch(fatal);
  });
} else {
  // Exit after reading in production mode.
  reading.then(function() {
    return process.exit(0);
  });
}
