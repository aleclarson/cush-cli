// Generated by CoffeeScript 2.3.0
var args, bun, cush, dest, dev, err, fatal, fs, log, main, path, promise, refresh, sha256, slurm, target;

slurm = require('slurm');

args = slurm({
  o: true, // output path
  t: true, // target platform
  p: true, // production mode
  h: true // help
});

if (/^(-h)?$/.test(args._)) {
  return (async function() {
    var fs, path;
    fs = require('saxon');
    path = require('path');
    console.log((await fs.read(path.resolve(__dirname, '../help.md'))));
    return process.exit();
  })();
}

log = require('lodge');

log.prefix(log.coal('[cli]'));

fatal = function(err) {
  var stack;
  if (typeof err === 'string') {
    log.error(err);
    process.exit(1);
  }
  if (process.env.DEBUG) {
    stack = err.stack.replace(err.name + ': ' + err.message + '\n', '');
    stack = '\n' + log.gray(stack);
  }
  log.error(err.message + (stack || ''));
  return process.exit(1);
};

if (!(main = args[0])) {
  fatal('must provide an entry path');
}

if (!(dest = args.o)) {
  fatal('must provide an output path (-o)');
}

if (!(target = args.t)) {
  // get the ".web" from "bundle.web.js"
  target = /\.([^.\/]+)\.[^.\/]+$/.exec(dest);
  if (target) {
    target = target[1];
  } else {
    fatal('must provide a target (-t)');
  }
}

fs = require('saxon');

path = require('path');

cush = require('cush');

cush.on('warning', function(evt) {
  return log.warn(evt);
});

cush.on('error', function(evt) {
  return fatal(evt.error);
});

dev = !args.p;

try {
  bun = cush.bundle(main, {target, dev});
} catch (error) {
  err = error;
  fatal(err);
}

if (dev) {
  bun.save = async function() {
    var content, map, parent;
    ({content, map} = (await this._result));
    await fs.mkdir(parent = path.dirname(dest));
    map.sourceRoot = path.relative(parent, '');
    await fs.write(dest, content + this.getSourceMapURL(map));
    return dest;
  };
} else {
  ({sha256} = require('cush/utils'));
  bun.save = async function() {
    var content, i, map, name, parent;
    ({content, map} = (await this._result));
    parent = path.dirname(dest);
    name = path.basename(dest);
    i = name.indexOf('.');
    name = name.slice(0, i) + '.' + sha256(content, 8) + name.slice(i);
    name = path.join(parent, name);
    await fs.mkdir(path.dirname(name));
    await fs.write(name, content + this.getSourceMapURL(name));
    map.sourceRoot = path.relative(parent, '');
    await fs.write(name + '.map', map.toString());
    return name;
  };
}

promise = null;

refresh = async function() {
  var name, result;
  result = (await bun.read());
  promise = null;
  if (bun.missed.length) {
    log('');
    log(log.red('failed to resolve dependencies: üî•'));
    bun.missed.forEach(function([mod, i]) {
      return log('  ' + mod.deps[i].ref + log.coal(' from ') + bun.relative(mod));
    });
    log('');
    return;
  }
  if (result) {
    log('');
    log('bundled in ' + log.lyellow(bun.elapsed + 'ms ‚ö°Ô∏è'));
    name = (await bun.save());
    log(`saved as ${log.lblue(name)} üíé`);
    log('');
  }
};

// The initial build.
promise = refresh().catch(fatal);

// Watch for changes in development mode.
dev && cush.on('change', function(file) {
  if (!bun.valid) {
    log.clear();
    promise || (promise = refresh().catch(fatal));
  }
});

// Exit after building in production mode.
dev || promise.then(function() {
  return process.exit(0);
});
